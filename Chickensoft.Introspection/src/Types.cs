namespace Chickensoft.Introspection;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

/// <summary>
/// LogicBlock type hierarchy lookup system â€” find and cache types by their
/// base type or ancestor without reflection, using the LogicBlocks Type
/// Generator output.
/// <br />
/// Be sure to call <see cref="Register"/> with the generated type registry
/// before using the other methods in this class.
/// </summary>
public static class Types {
  private static readonly HashSet<Type> _visibleTypes = new();
  private static readonly Dictionary<Type, Func<object>>
    _visibleInstantiableTypes = new();
  private static readonly Dictionary<Type, IMetatype> _metatypes = new();
  private static readonly Dictionary<Type, HashSet<Type>> _typesByBaseType =
    new();
  private static readonly Dictionary<Type, HashSet<Type>> _typesByAncestor =
    new();
  private static readonly Dictionary<Type, List<PropertyMetadata>>
    _allPropertiesByType = new();
  private static readonly Dictionary<Type, List<Attribute>>
    _allAttributesByType = new();
  private static readonly Dictionary<string, Type> _introspectiveTypesById =
    new();

  internal static void Reset() {
    _visibleTypes.Clear();
    _visibleInstantiableTypes.Clear();
    _metatypes.Clear();
    _typesByBaseType.Clear();
    _typesByAncestor.Clear();
    _allPropertiesByType.Clear();
    _allAttributesByType.Clear();
    _introspectiveTypesById.Clear();
  }

  /// <summary>
  /// Computes and caches secondary type lookup tables based on the types
  /// registered in the provided type registry.
  /// </summary>
  /// <param name="registry">Type registry generated by the
  /// LogicBlocksTypeGenerator.</param>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Register(ITypeRegistry registry) {
    RegisterTypes(registry);
    ComputeTypesByBaseType(registry);
    ComputeIntrospectiveTypesById(registry);
  }

  /// <summary>
  /// Gets all the derived types of the given type. Does not work for
  /// interfaces. Caches the derived types for speedy lookups later.
  /// </summary>
  /// <param name="type">Ancestor type.</param>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static HashSet<Type> GetDescendants(Type type) {
    CacheDescendants(type);
    return _typesByAncestor[type];
  }

  /// <summary>
  /// Returns types that derive from the given type. Only returns directly
  /// derived types, not descendants.
  /// </summary>
  /// <param name="type">Parent type.</param>
  /// <returns>Immediate subtypes.</returns>
  public static HashSet<Type> GetDerivedTypes(Type type) =>
    _typesByBaseType[type];

  /// <summary>
  /// Gets all the properties of the given metatype, including the properties
  /// inherited from any base metatypes that the type extends.
  /// </summary>
  /// <param name="registry">Type registry generated by the
  /// LogicBlocksTypeGenerator.</param>
  /// <param name="type"></param>
  /// <returns>All properties of the metatype, including the properties
  /// inherited from any base metatypes that the type extends.</returns>
  public static IEnumerable<PropertyMetadata> GetAllProperties(
    ITypeRegistry registry, Type type
  ) {
    if (_allPropertiesByType.TryGetValue(type, out var properties)) {
      return properties;
    }

    GetMetatypeOrThrow(registry, type); // Validate type is metatype.

    properties = new List<PropertyMetadata>();
    var currentType = type;

    do {
      if (registry.Metatypes.TryGetValue(currentType, out var metatype)) {
        foreach (var property in metatype.Properties) {
          properties.Add(property);
        }
      }

      currentType = currentType.BaseType;
    } while (currentType != null);

    return properties;
  }

  /// <summary>
  /// Gets all the attributes of the given type, including the attributes
  /// inherited from any base metatypes that the type extends.
  /// </summary>
  /// <param name="registry">Type registry generated by the
  /// LogicBlocksTypeGenerator.</param>
  /// <param name="type"></param>
  /// <returns>All attributes of the type, including the attributes inherited
  /// from any base metatypes that the type extends.</returns>
  public static IDictionary<Type, Attribute[]> GetAllAttributes(
    ITypeRegistry registry, Type type
  ) =>
    GetMetatypeAndBaseMetatypes(type)
      .SelectMany((t) => registry.Metatypes[t].Attributes)
      .ToDictionary(
        keySelector: (typeToAttr) => typeToAttr.Key,
        elementSelector: (typeToAttr) => typeToAttr.Value
      );

  #region Private Utilities

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static void CacheDescendants(Type type) {
    if (_typesByAncestor.ContainsKey(type)) { return; }

    _typesByAncestor.Add(type, FindDescendants(type));
  }

  private static HashSet<Type> FindDescendants(Type type) {
    var descendants = new HashSet<Type>();
    var queue = new Queue<Type>();
    queue.Enqueue(type);

    while (queue.Count > 0) {
      var currentType = queue.Dequeue();
      descendants.Add(currentType);

      if (_typesByBaseType.TryGetValue(currentType, out var children)) {
        foreach (var child in children) {
          queue.Enqueue(child);
        }
      }
    }

    descendants.Remove(type);

    return descendants;
  }

  private static void RegisterTypes(ITypeRegistry registry) {
    // Iterate through all visible types in O(n) time and add them to our
    // internal caches.
    // Why do this? We want to allow multiple assemblies to use this system to
    // find types by their base type or ancestor.
    foreach (var type in registry.VisibleTypes) {
      _visibleTypes.Add(type);

      if (registry.VisibleInstantiableTypes.ContainsKey(type)) {
        _visibleInstantiableTypes[type] =
          registry.VisibleInstantiableTypes[type];
      }

      if (registry.Metatypes.ContainsKey(type)) {
        _metatypes[type] = registry.Metatypes[type];
      }
    }
  }

  private static void ComputeTypesByBaseType(ITypeRegistry registry) {
    // Iterate through each type in the registry and its base types,
    // constructing a flat map of base types to their immediately derived types.
    // The beauty of this approach is that it discovers base types which may be
    // in other modules, and works in reflection-free mode since BaseType is
    // always supported by every C# environment, even AOT environments.
    foreach (var type in registry.VisibleTypes) {
      var lastType = type;
      var baseType = type.BaseType;

      while (baseType != null) {
        if (!_typesByBaseType.TryGetValue(baseType, out var existingSet)) {
          existingSet = new HashSet<Type>();
          _typesByBaseType.Add(baseType, existingSet);
        }
        existingSet.Add(lastType);

        lastType = baseType;
        baseType = lastType.BaseType;
      }
    }
  }

  private static void ComputeIntrospectiveTypesById(ITypeRegistry registry) {
    foreach (var type in registry.Metatypes.Keys) {
      _introspectiveTypesById[registry.Metatypes[type].Id] = type;
    }
  }

  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static IMetatype GetMetatypeOrThrow(
    ITypeRegistry registry, Type type
  ) {
    if (!registry.Metatypes.TryGetValue(type, out var metatype)) {
      throw new InvalidOperationException(
        $"Type {type} is not an introspective type. To make a type " +
        $"introspective, add the [{nameof(IntrospectiveAttribute)}] " +
        "to it so the introspection generator will generate a metatype " +
        "description of it."
      );
    }

    return metatype;
  }

  /// <summary>
  /// Enumerates through a type and its base type hierarchy to discover all
  /// metatypes that describe the type and its base types.
  /// </summary>
  /// <param name="type">Type whose type hierarchy should be examined.</param>
  /// <returns>The type's metatype (if it has one), and any metatypes that
  /// describe its base types, in the order of the most derived type to the
  /// least derived type.</returns>
  private static IEnumerable<Type> GetMetatypeAndBaseMetatypes(Type type) {
    var currentType = type;

    do {
      if (_metatypes.ContainsKey(currentType)) {
        yield return currentType;
      }

      currentType = currentType.BaseType;
    } while (currentType != null);
  }

  #endregion Private Utilities
}

namespace Chickensoft.LogicBlocks;

using System;
using System.Collections.Generic;
using Chickensoft.Introspection;

public abstract partial class LogicBlock<TState> {
  internal static ITypeGraph DefaultGraph => Introspection.Types.Graph;
  // Graph to use for introspection. Allows it to be shimmed for testing.
  internal static ITypeGraph Graph { get; set; } = DefaultGraph;

  /// <summary>
  /// Adds an instance of every concrete state type in the state hierarchy to
  /// the blackboard. For this to work, the logic block and its states must be
  /// introspective types whose introspection metadata is generated by the
  /// Chickensoft.Introspection generator.
  /// </summary>
  /// <param name="logic">Logic block whose states should be preallocated.
  /// </param>
  /// <exception cref="LogicBlockException" />
  internal static void PreallocateStates(ILogicBlock<TState> logic) {
    var type = logic.GetType();
    // If we're not an introspective type, we can't examine our state hierarchy.
    if (!Graph.IsIntrospectiveType(type)) {
      return;
    }

    var metatype = Graph.GetMetatype(type);

    var logicBlockAttributes =
      metatype.Attributes.ContainsKey(typeof(LogicBlockAttribute))
        ? metatype.Attributes[typeof(LogicBlockAttribute)]
        : null;

    // Identify the logic block attribute, if any.
    if (
      logicBlockAttributes is not { } attributes ||
      attributes.Length < 1 ||
      attributes[0] is not LogicBlockAttribute logicBlockAttribute
    ) {
      return;
    }

    var baseStateType = logicBlockAttribute.StateType;

    var subtypes = Graph.GetDescendantSubtypes(baseStateType);

    var stateTypesThatAreNotIntrospective =
      new HashSet<Type>(subtypes.Count + 1);

    if (!Graph.IsIntrospectiveType(baseStateType)) {
      stateTypesThatAreNotIntrospective.Add(baseStateType);
    }

    if (Graph.IsConcrete(baseStateType)) {
      logic.SaveObject(
        baseStateType, () => Activator.CreateInstance(baseStateType)
      );
      // Force type to be created and added to the blackboard.
      logic.GetObject(baseStateType);
    }

    foreach (var stateType in subtypes) {
      if (!Graph.IsIntrospectiveType(stateType)) {
        stateTypesThatAreNotIntrospective.Add(stateType);
        continue;
      }

      if (!Graph.IsConcrete(stateType)) {
        continue;
      }

      // Mark the state as persisted and add a factory for it to the
      // blackboard that will be used if we do not end up deserializing
      // the state later.
      if (logic.HasObject(stateType)) {
        throw new LogicBlockException(
          $"LogicBlock `{type}` has a conflicting blackboard value for " +
          $"`{stateType}`. Please avoid adding blackboard values for " +
          "states that are part of a LogicBlock's state hierarchy to " +
          "enable state preallocation to work correctly."
        );
      }

      logic.SaveObject(
        stateType, () => Activator.CreateInstance(stateType)
      );

      // Force type to be created and added to the blackboard.
      logic.GetObject(stateType);
    }

    if (stateTypesThatAreNotIntrospective.Count == 0) { return; }

    var statesNeedingAttention = string.Join(
      ", ", stateTypesThatAreNotIntrospective
    );

    throw new LogicBlockException(
      $"Introspective LogicBlock `{type}` has states that are missing the " +
      $"[{nameof(IntrospectiveAttribute)}] attribute and cannot be " +
      $"preallocated: {statesNeedingAttention}."
    );
  }
}

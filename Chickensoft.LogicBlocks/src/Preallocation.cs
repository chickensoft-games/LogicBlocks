namespace Chickensoft.LogicBlocks;

using System;
using System.Collections.Generic;
using Chickensoft.Introspection;

public abstract partial class LogicBlock<TState> {
  internal static ITypeGraph DefaultGraph => Introspection.Types.Graph;
  // Graph to use for introspection. Allows it to be shimmed for testing.
  internal static ITypeGraph Graph { get; set; } = DefaultGraph;

  /// <summary>
  /// Adds an instance of every concrete state type in the state hierarchy to
  /// the blackboard. For this to work, the logic block and its states must be
  /// introspective types whose introspection metadata is generated by the
  /// Chickensoft.Introspection generator.
  /// </summary>
  /// <param name="logic">Logic block whose states should be preallocated.
  /// </param>
  /// <exception cref="LogicBlockException" />
  internal static void PreallocateStates(ILogicBlock<TState> logic) {
    var type = logic.GetType();
    // If we're not an introspective type, we can't examine our state hierarchy.
    if (!Graph.IsIntrospectiveType(type)) {
      return;
    }

    var metatype = Graph.GetMetatype(type);

    var logicBlockAttributes =
      metatype.Attributes.ContainsKey(typeof(LogicBlockAttribute))
        ? metatype.Attributes[typeof(LogicBlockAttribute)]
        : null;

    // Identify the logic block attribute, if any.
    if (
      logicBlockAttributes is not { } attributes ||
      attributes.Length < 1 ||
      attributes[0] is not LogicBlockAttribute logicBlockAttribute
    ) {
      return;
    }

    // See if logic block is an identifiable, introspective type (serializable).
    // If it is, we will throw if any of its states are not also identifiable,
    // introspective types. If we're not an identifiable, introspective type,
    // we don't need to perform additional validation for serialization â€”
    // just do enough to preallocate states and be done.
    var isIdentifiable = metatype.Id is not null;

    bool isValidStateType(Type type) {
      // All states are valid if we're not a serializable logic block.
      if (!isIdentifiable) { return true; }
      // Serializable logic blocks require all states to also be serializable.
      return Graph.IsIdentifiableType(type);
    }

    var baseStateType = logicBlockAttribute.StateType;

    var subtypes = Graph.GetDescendantSubtypes(baseStateType);

    var stateTypesNeedingAttention = new HashSet<Type>(subtypes.Count + 1);

    if (!isValidStateType(baseStateType)) {
      stateTypesNeedingAttention.Add(baseStateType);
    }

    if (Graph.IsConcrete(baseStateType)) {
      var factory =
        Graph.ConcreteVisibleTypes[baseStateType].Factory;
      logic.SaveObject(baseStateType, factory);
      // Force type to be created and added to the blackboard.
      // Reasoning: do as much heap allocation as possible during setup
      // instead of during execution.
      logic.GetObject(baseStateType);
    }

    foreach (var stateType in subtypes) {
      if (!isValidStateType(stateType)) {
        stateTypesNeedingAttention.Add(stateType);
        continue;
      }

      if (!Graph.IsConcrete(stateType)) {
        continue;
      }

      // Mark the state as persisted and add a factory for it to the
      // blackboard that will be used if we do not end up deserializing
      // the state later.
      if (logic.HasObject(stateType)) {
        // Don't preallocate states that have been manually added.
        continue;
      }

      var factory = Graph.ConcreteVisibleTypes[stateType].Factory;

      if (!ReferenceStates.ContainsKey(stateType)) {
        ReferenceStates.TryAdd(stateType, factory());
      }

      logic.SaveObject(stateType, factory);

      // Force type to be created and added to the blackboard.
      // Reasoning: do as much heap allocation as possible during setup
      // instead of during execution.
      logic.GetObject(stateType);
    }

    if (stateTypesNeedingAttention.Count == 0) { return; }

    var statesNeedingAttention = string.Join(
      ", ", stateTypesNeedingAttention
    );

    throw new LogicBlockException(
      $"Serializable LogicBlock `{type}` has states that are not " +
      $"serializable. Please ensure the following types have the " +
      $"[{nameof(MetaAttribute)}] and [{nameof(IdAttribute)}] attributes: " +
      $"{statesNeedingAttention}."
    );
  }
}

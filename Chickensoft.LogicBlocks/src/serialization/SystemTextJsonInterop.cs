namespace Chickensoft.Serialization;

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization.Metadata;
using Chickensoft.Introspection;

/// <summary>
/// Interop utility to allow the serialization system to piggyback off of
/// System.Text.Json for maximum compatibility (and to avoid the need to
/// construct yet another serialization system).
/// </summary>
public class SystemTextJsonInterop {
  private readonly Dictionary<Type, JsonTypeInfo> _jsonTypeInfosByType = new();

  /// <summary>
  /// Creates (or retrieves from cache) a JsonTypeInfo instance for the given
  /// type, using the provided type registry and serializer options. If the type
  /// is not a metatype tagged with the <see cref="IntrospectiveAttribute"/>,
  /// this method will throw an exception.
  /// </summary>
  /// <param name="registry">Type registry generated by the
  /// LogicBlocksTypeGenerator.</param>
  /// <param name="options">Json serializer options.</param>
  /// <param name="type">System type.</param>
  /// <returns>Json type info for the provided type's metatype.</returns>
  public JsonTypeInfo CreateJsonTypeInfo(
    ITypeRegistry registry,
    JsonSerializerOptions options,
    Type type
  ) {
    if (_jsonTypeInfosByType.TryGetValue(type, out var jsonTypeInfo)) {
      return jsonTypeInfo;
    }

    var metatype = registry.Metatypes[type];

    // We can safely disregard AOT warnings since we know the types will not
    // be trimmed since they are registered in the generated type registry by
    // the logic blocks generator, in addition to the fact that we are
    // providing type information for all serializable, non-primitive types.

    // #pragma warning disable IL2026, IL3050
    jsonTypeInfo = JsonTypeInfo.CreateJsonTypeInfo(type, options);

    var polymorphismOptions = jsonTypeInfo.PolymorphismOptions ??= new();

    // Set type discriminator based on metatype id provided by developer.
    polymorphismOptions.TypeDiscriminatorPropertyName = metatype.Id;

    // Register immediately derived types for polymorphic serialization.
    foreach (var derivedType in Types.GetDerivedTypes(type)) {
      polymorphismOptions.DerivedTypes.Add(
        new JsonDerivedType(derivedType, derivedType.Name)
      );
    }

    // Allow the json serializer to construct an instance of the type.
    jsonTypeInfo.CreateObject = registry.VisibleInstantiableTypes[type];

    foreach (var property in metatype.Properties) {
      if (!property.AttributesByType.ContainsKey(typeof(SaveAttribute))) {
        // Only serialize properties with the [Save] attribute.
        continue;
      }

      // Look at the property metadata generated by the logic blocks generator
      // and construct the relevant JsonPropertyInfo for each property.
      var jsonProp = jsonTypeInfo.CreateJsonPropertyInfo(
        property.Type, property.Name
      );
      jsonProp.IsRequired = false;
      jsonProp.Get = property.Getter;
      jsonProp.Set = property.Setter;

      jsonTypeInfo.Properties.Add(jsonProp);
    }

    // Cache type info so we don't construct it more than once.
    _jsonTypeInfosByType[type] = jsonTypeInfo;

    return jsonTypeInfo;
    // #pragma warning restore IL2026, IL3050
  }
}

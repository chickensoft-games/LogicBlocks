namespace Chickensoft.LogicBlocks;

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using Chickensoft.LogicBlocks.Types;

public partial class LogicBlock<TState> {
  private static readonly Dictionary<Type, HashSet<Type>> _typesByBaseType =
    new();
  private static readonly Dictionary<Type, HashSet<Type>> _typesByAncestor =
    new();

  /// <summary>
  /// This caches the types shown in the generated registry by their base type
  /// for more performant type-hierarchy lookups later.
  /// </summary>
  /// <param name="registry">Type registry generated by the
  /// LogicBlocksTypeGenerator.</param>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static void Initialize(ITypeRegistry registry) =>
    ComputeTypesByBaseType(registry);

  /// <summary>
  /// Gets all the derived types of the given type. Does not work for
  /// interfaces. Caches the derived types for speedy lookups later.
  /// </summary>
  /// <param name="type">Ancestor type.</param>
  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  public static HashSet<Type> GetDescendants(Type type) {
    CacheDescendants(type);
    return _typesByAncestor[type];
  }


  [MethodImpl(MethodImplOptions.AggressiveInlining)]
  private static void CacheDescendants(Type type) {
    if (_typesByAncestor.ContainsKey(type)) { return; }

    _typesByAncestor.Add(type, FindDescendants(type));
  }

  private static HashSet<Type> FindDescendants(Type type) {
    var descendants = new HashSet<Type>();
    var queue = new Queue<Type>();
    queue.Enqueue(type);

    while (queue.Count > 0) {
      var current = queue.Dequeue();
      descendants.Add(current);

      if (_typesByBaseType.TryGetValue(current, out var children)) {
        foreach (var child in children) {
          queue.Enqueue(child);
        }
      }
    }

    descendants.Remove(type);

    return descendants;
  }

  private static void ComputeTypesByBaseType(ITypeRegistry registry) {
    foreach (var type in registry.VisibleTypes) {
      if (type.BaseType is not Type baseType) { continue; }

      if (_typesByBaseType.TryGetValue(baseType, out var existingSet)) {
        existingSet.Add(type);
      }
      else {
        var set = new HashSet<Type>();
        set.Add(type);
        _typesByBaseType.Add(baseType, set);
      }
    }
  }
}
